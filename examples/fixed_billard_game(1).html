<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>🎱 BILLARD ÉPIQUE - MULTIJOUEUR</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
  
  :root{
    --neon-cyan:#00ffff;
    --neon-pink:#ff00ff;
    --neon-green:#39ff14;
    --neon-orange:#ff8800;
    --dark-bg:#0a0a0a;
    --dark-card:#1a1a1a;
    --felt:#1a4a2e;
    --rail:#0d2818;
    --gold:#ffd700;
    --shadow:0 0 20px rgba(0,255,255,0.3);
    --glow:0 0 30px;
  }
  
  * { box-sizing: border-box; }
  
  html,body{height:100%;margin:0;padding:0;overflow-x:hidden}
  body{
    font-family:'Orbitron',monospace;
    background:linear-gradient(45deg,#0a0a0a,#1a0a1a,#0a1a0a);
    background-size:400% 400%;
    animation:bgShift 20s ease infinite;
    color:#fff;
  }
  
  @keyframes bgShift {
    0%{background-position:0% 50%}
    50%{background-position:100% 50%}
    100%{background-position:0% 50%}
  }
  
  .app{
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:20px;
    gap:20px;
    min-height:100vh;
  }
  
  .header{
    width:100%;
    max-width:1200px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    background:rgba(26,26,26,0.8);
    backdrop-filter:blur(10px);
    border:1px solid var(--neon-cyan);
    border-radius:15px;
    padding:15px 25px;
    box-shadow:var(--shadow);
  }
  
  .brand{
    display:flex;
    align-items:center;
    gap:15px;
    font-weight:900;
    font-size:24px;
    text-transform:uppercase;
    letter-spacing:2px;
  }
  
  .brand .logo{
    font-size:32px;
    animation:pulse 2s infinite;
    filter:drop-shadow(0 0 10px var(--neon-cyan));
  }
  
  @keyframes pulse {
    0%,100%{transform:scale(1)}
    50%{transform:scale(1.1)}
  }
  
  .brand-text{
    background:linear-gradient(45deg,var(--neon-cyan),var(--neon-pink));
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
  }
  
  .btn{
    appearance:none;
    background:linear-gradient(45deg,var(--neon-cyan),var(--neon-pink));
    border:none;
    color:#000;
    padding:12px 20px;
    border-radius:25px;
    font-family:inherit;
    font-weight:700;
    text-transform:uppercase;
    cursor:pointer;
    transition:all 0.3s ease;
    box-shadow:var(--glow) var(--neon-cyan);
    position:relative;
    overflow:hidden;
    z-index:10;
  }
  
  .btn:hover{
    transform:translateY(-3px);
    box-shadow:var(--glow) var(--neon-pink);
  }
  
  .btn:active{transform:scale(0.95)}
  .btn:disabled{opacity:0.5;cursor:not-allowed;transform:none}
  
  .btn.secondary{
    background:rgba(26,26,26,0.8);
    color:var(--neon-cyan);
    border:2px solid var(--neon-cyan);
  }
  
  .card{
    background:rgba(26,26,26,0.9);
    backdrop-filter:blur(15px);
    border:1px solid var(--neon-cyan);
    border-radius:20px;
    padding:25px;
    width:100%;
    max-width:800px;
    box-shadow:var(--shadow);
    position:relative;
  }
  
  .row{display:flex;flex-wrap:wrap;gap:20px;align-items:flex-start}
  .col{flex:1;min-width:200px}
  
  label{
    display:block;
    font-size:14px;
    color:var(--neon-green);
    margin-bottom:8px;
    text-transform:uppercase;
    letter-spacing:1px;
  }
  
  input[type="text"]{
    width:100%;
    padding:12px 15px;
    border-radius:15px;
    border:2px solid var(--neon-cyan);
    background:rgba(0,0,0,0.7);
    color:#fff;
    font-family:inherit;
    transition:all 0.3s ease;
    box-sizing:border-box;
  }
  
  input[type="text"]:focus{
    outline:none;
    border-color:var(--neon-pink);
    box-shadow:var(--glow) var(--neon-pink);
  }
  
  .check{
    display:flex;
    align-items:center;
    gap:10px;
    margin-top:10px;
  }
  
  .check input{
    width:20px;
    height:20px;
    accent-color:var(--neon-cyan);
  }
  
  .stars{
    display:flex;
    gap:15px;
    margin:10px 0;
    flex-wrap:wrap;
  }
  
  .stars input{display:none}
  
  .stars label{
    padding:10px 15px;
    border-radius:25px;
    border:2px solid var(--neon-orange);
    background:rgba(0,0,0,0.7);
    color:var(--neon-orange);
    cursor:pointer;
    transition:all 0.3s ease;
    font-weight:700;
    text-transform:uppercase;
  }
  
  .stars label:hover{
    transform:translateY(-2px);
    box-shadow:var(--glow) var(--neon-orange);
  }
  
  #diff1:checked+label{
    background:var(--neon-green);
    color:#000;
    box-shadow:var(--glow) var(--neon-green);
  }
  
  #diff2:checked+label{
    background:var(--neon-orange);
    color:#000;
    box-shadow:var(--glow) var(--neon-orange);
  }
  
  #diff3:checked+label{
    background:var(--neon-pink);
    color:#000;
    box-shadow:var(--glow) var(--neon-pink);
  }
  
  .help{
    font-size:12px;
    color:#888;
    margin-top:8px;
  }
  
  .game-area{
    width:100%;
    max-width:1200px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:20px;
  }
  
  .scores-hud{
    display:flex;
    justify-content:center;
    gap:30px;
    padding:15px 30px;
    background:rgba(26,26,26,0.9);
    backdrop-filter:blur(10px);
    border:1px solid var(--neon-cyan);
    border-radius:50px;
    box-shadow:var(--shadow);
  }
  
  .player-score{
    display:flex;
    align-items:center;
    gap:15px;
    font-weight:700;
  }
  
  .player-name{
    color:var(--neon-cyan);
    text-transform:uppercase;
  }
  
  .score-value{
    background:linear-gradient(45deg,var(--neon-pink),var(--neon-cyan));
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
    font-size:24px;
    font-weight:900;
  }
  
  .vs{
    color:var(--neon-orange);
    font-size:20px;
    animation:pulse 2s infinite;
  }
  
  .board-container{
    position:relative;
    width:100%;
    max-width:1000px;
    aspect-ratio:960/580;
    background:linear-gradient(145deg,var(--rail),#0a3a1a);
    border-radius:25px;
    padding:25px;
    border:3px solid var(--neon-cyan);
    box-shadow:
      var(--glow) var(--neon-cyan),
      inset 0 0 50px rgba(0,0,0,0.5);
  }
  
  .felt{
    position:relative;
    width:100%;
    height:100%;
    background:linear-gradient(180deg,var(--felt),#0d3a1d);
    border-radius:15px;
    overflow:hidden;
    border:2px solid var(--neon-green);
    box-shadow:inset 0 0 30px rgba(0,0,0,0.7);
  }
  
  canvas{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    z-index:2;
    touch-action:none;
    cursor:crosshair;
  }
  
  .hud{
    position:absolute;
    left:0;right:0;top:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    padding-top:15px;
    z-index:3;
  }
  
  .turn-indicator{
    background:rgba(0,0,0,0.8);
    backdrop-filter:blur(10px);
    padding:10px 25px;
    border-radius:25px;
    border:2px solid var(--neon-cyan);
    display:flex;
    align-items:center;
    gap:15px;
    font-weight:700;
    text-transform:uppercase;
    box-shadow:var(--glow) var(--neon-cyan);
    animation:fadeInDown 0.5s ease;
    transition:opacity 0.5s ease;
  }
  
  @keyframes fadeInDown {
    from{opacity:0;transform:translateY(-20px)}
    to{opacity:1;transform:translateY(0)}
  }
  
  .turn-ball{
    width:20px;
    height:20px;
    border-radius:50%;
    border:2px solid rgba(255,255,255,0.3);
    animation:spin 3s linear infinite;
  }
  
  @keyframes spin {
    from{transform:rotate(0deg)}
    to{transform:rotate(360deg)}
  }
  
  .turn-ball.white{background:#fff;box-shadow:0 0 15px #fff}
  .turn-ball.black{background:#000;box-shadow:0 0 15px var(--neon-cyan)}
  
  .overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.8);
    backdrop-filter:blur(10px);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:50;
    animation:fadeIn 0.5s ease;
  }
  
  @keyframes fadeIn {
    from{opacity:0}
    to{opacity:1}
  }
  
  .overlay.hidden{display:none}
  
  .modal{
    background:rgba(26,26,26,0.95);
    backdrop-filter:blur(20px);
    padding:40px;
    border-radius:25px;
    border:2px solid var(--neon-cyan);
    box-shadow:var(--glow) var(--neon-cyan);
    text-align:center;
    max-width:500px;
    width:90%;
    animation:modalPop 0.5s ease;
  }
  
  @keyframes modalPop {
    from{transform:scale(0.8);opacity:0}
    to{transform:scale(1);opacity:1}
  }
  
  .modal h2{
    margin:0 0 20px;
    font-size:32px;
    font-weight:900;
    text-transform:uppercase;
    background:linear-gradient(45deg,var(--neon-cyan),var(--neon-pink));
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
  }
  
  .modal p{
    margin:15px 0 30px;
    color:#ccc;
    font-size:18px;
  }
  
  .power-meter{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    width:200px;
    height:10px;
    background:rgba(0,0,0,0.7);
    border:2px solid var(--neon-cyan);
    border-radius:10px;
    overflow:hidden;
    z-index:4;
    opacity:0;
    transition:opacity 0.3s ease;
  }
  
  .power-meter.visible{opacity:1}
  
  .power-fill{
    height:100%;
    background:linear-gradient(90deg,var(--neon-green),var(--neon-orange),var(--neon-pink));
    width:0%;
    transition:width 0.1s ease;
    border-radius:5px;
  }
  
  .grabbable{cursor:grab}
  .grabbing{cursor:grabbing}
  
  .combo-text{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    font-size:48px;
    font-weight:900;
    color:var(--neon-pink);
    text-shadow:var(--glow) var(--neon-pink);
    pointer-events:none;
    z-index:10;
    animation:comboAnim 2s ease forwards;
  }
  
  @keyframes comboAnim {
    0%{opacity:0;transform:translate(-50%,-50%) scale(0.5)}
    50%{opacity:1;transform:translate(-50%,-50%) scale(1.2)}
    100%{opacity:0;transform:translate(-50%,-50%) scale(1)}
  }
  
  @media (max-width: 768px) {
    .header{flex-direction:column;gap:15px}
    .brand{font-size:20px}
    .row{flex-direction:column}
    .stars{justify-content:center}
    .scores-hud{flex-direction:column;gap:15px}
    .modal{padding:25px}
    .modal h2{font-size:24px}
    
    /* Mobile: Banner plus petit et plus discret */
    .turn-indicator{
      padding:8px 20px;
      font-size:12px;
      top:10px;
      position:absolute;
      opacity:0.9;
    }
    
    .turn-ball{
      width:16px;
      height:16px;
    }
    
    .hud{
      padding-top:10px;
    }
  }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="brand">
      <span class="logo">🎱</span>
      <span class="brand-text">BILLARD ÉPIQUE</span>
    </div>
    <button id="restartBtn" class="btn secondary">NOUVELLE PARTIE</button>
  </div>

  <!-- Écran d'accueil -->
  <div id="startScreen" class="card">
    <!-- Mode de jeu -->
    <div class="row">
      <div class="col">
        <label>🎮 MODE DE JEU</label>
        <div class="stars">
          <input type="radio" name="gameMode" id="modeLocal" value="local" checked>
          <label for="modeLocal">👥 LOCAL</label>
          <input type="radio" name="gameMode" id="modeAI" value="ai">
          <label for="modeAI">🤖 VS IA</label>
          <input type="radio" name="gameMode" id="modeHost" value="host">
          <label for="modeHost">🏠 HÉBERGER</label>
          <input type="radio" name="gameMode" id="modeJoin" value="join">
          <label for="modeJoin">🌐 REJOINDRE</label>
        </div>
      </div>
    </div>

    <!-- Section IA -->
    <div id="aiSection" style="display:none">
    <div id="p2pSection" style="display:none">
      <div class="row">
        <div class="col">
          <div id="hostSection" style="display:none">
            <label>🔗 VOTRE ID DE PARTIE</label>
            <div style="position:relative;">
              <div style="background:rgba(0,0,0,0.5);padding:15px;border-radius:10px;border:2px solid var(--neon-cyan);font-family:monospace;font-size:18px;text-align:center;margin:10px 0;word-break:break-all;min-height:60px;display:flex;align-items:center;justify-content:center;" id="myPeerId">
                Génération en cours...
              </div>
              <button id="copyIdBtn" class="btn" style="position:absolute;top:15px;right:15px;padding:8px 12px;font-size:12px;display:none;" onclick="copyPeerIdToClipboard()">
                📋 COPIER
              </button>
            </div>
            <div class="help">📤 Cliquez "COPIER" puis envoyez l'ID à votre adversaire ! <br>
            💡 <strong>Alternative :</strong> Utilisez le mode LOCAL pour jouer sur le même écran</div>
            <div style="display:flex;align-items:center;gap:10px;margin:15px 0;">
              <div style="width:12px;height:12px;border-radius:50%;background:#666;" id="statusDot"></div>
              <span id="statusText">En attente de connexion...</span>
            </div>
          </div>
          
          <div id="joinSection" style="display:none">
            <label for="friendId">🎯 ID DE VOTRE ADVERSAIRE</label>
            <input id="friendId" type="text" placeholder="Collez l'ID ici..." style="margin:10px 0;" />
            <button id="connectBtn" class="btn" style="width:100%;margin:10px 0;">🔗 SE CONNECTER</button>
            <div class="help">💡 <strong>Plus simple :</strong> Utilisez le mode LOCAL (même écran, même appareil)</div>
            <div style="display:flex;align-items:center;gap:10px;margin:15px 0;">
              <div style="width:12px;height:12px;border-radius:50%;background:#666;" id="statusDot2"></div>
              <span id="statusText2">Prêt à se connecter</span>
            </div>
          </div>
          
          <div id="connectionInfo" style="display:none;background:rgba(0,255,255,0.1);border:2px solid var(--neon-cyan);border-radius:15px;padding:15px;margin:15px 0;">
            <div style="font-weight:700;color:var(--neon-green);margin-bottom:10px;">✅ CONNEXION ÉTABLIE!</div>
            <div style="font-size:12px;">
              <div>PING: <span id="pingDisplay">-</span>ms</div>
              <div>STATUT: <span id="syncDisplay">SYNC</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>
      <div class="row">
        <div class="col">
          <label>🤖 NIVEAU DE L'IA</label>
          <div class="stars">
            <input type="radio" name="aiLevel" id="ai1" value="1" checked>
            <label for="ai1">EASY</label>
            <input type="radio" name="aiLevel" id="ai2" value="2">
            <label for="ai2">HARD</label>
            <input type="radio" name="aiLevel" id="ai3" value="3">
            <label for="ai3">INSANE</label>
          </div>
          <div class="help">EASY: Tire au hasard • HARD: Stratégie basique • INSANE: Calculs parfaits</div>
        </div>
      </div>
    </div>

    <!-- Joueurs -->
    <div class="row">
      <div class="col">
        <label for="p1">🤖 PLAYER 1 (BLANC)</label>
        <input id="p1" type="text" placeholder="Joueur 1" value="Joueur 1" />
        <div class="check">
          <input id="assistP1" type="checkbox" checked>
          <label for="assistP1">Assistance de visée</label>
        </div>
      </div>
      <div class="col" id="player2Section">
        <label for="p2">⚡ PLAYER 2 (NOIR)</label>
        <input id="p2" type="text" placeholder="Joueur 2" value="Joueur 2" />
        <div class="check">
          <input id="assistP2" type="checkbox" checked>
          <label for="assistP2">Assistance de visée</label>
        </div>
      </div>
    </div>
    
    <div class="row" style="margin-top:25px">
      <div class="col">
        <label>🔥 NIVEAU DE DIFFICULTÉ</label>
        <div class="stars">
          <input type="radio" name="difficulty" id="diff1" value="1">
          <label for="diff1">NOOB</label>
          <input type="radio" name="difficulty" id="diff2" value="2" checked>
          <label for="diff2">PRO</label>
          <input type="radio" name="difficulty" id="diff3" value="3">
          <label for="diff3">LEGEND</label>
        </div>
        <div class="help">NOOB: Trou géant • PRO: Équilibré • LEGEND: Mode hardcore</div>
      </div>
    </div>
    
    <div class="row" style="margin-top:30px;align-items:center;justify-content:space-between">
      <div class="help" style="color:var(--neon-cyan)">
        👆 Touche une boule, tire en arrière, relâche pour DÉTRUIRE !
      </div>
      <button id="startBtn" class="btn">🚀 COMMENCER LE MASSACRE</button>
    </div>
  </div>

  <!-- Zone de jeu -->
  <div id="gameUI" style="display:none" class="game-area">
    <div class="scores-hud">
      <div class="player-score">
        <span id="name1" class="player-name">Player 1</span>
        <span id="score1" class="score-value">0</span>
      </div>
      <span class="vs">VS</span>
      <div class="player-score">
        <span id="name2" class="player-name">Player 2</span>
        <span id="score2" class="score-value">0</span>
      </div>
    </div>
    
    <div class="board-container">
      <div class="felt">
        <canvas id="game" width="912" height="532"></canvas>
        
        <!-- HUD -->
        <div class="hud">
          <div class="turn-indicator" id="turnBanner">
            <div class="turn-ball white" id="turnBall"></div>
            <div id="turnText">PRÉPARE-TOI...</div>
          </div>
        </div>
        
        <!-- Jauge de puissance -->
        <div class="power-meter" id="powerMeter">
          <div class="power-fill" id="powerFill"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Overlays -->
  <div id="nextOverlay" class="overlay hidden">
    <div class="modal">
      <h2>🏆 MANCHE TERMINÉE</h2>
      <p id="roundResult">Résultat...</p>
      <button id="nextBtn" class="btn">MANCHE SUIVANTE</button>
    </div>
  </div>

  <div id="victoryOverlay" class="overlay hidden">
    <div class="modal">
      <h2 id="victoryTitle">👑 VICTOIRE ÉPIQUE!</h2>
      <p id="victorySubtitle">... domine le terrain!</p>
      <button id="playAgainBtn" class="btn">REVANCHE!</button>
    </div>
  </div>
</div>

<script>
// Chargement dynamique de PeerJS avec fallbacks
function loadPeerJS() {
  return new Promise((resolve, reject) => {
    // Si PeerJS est déjà chargé
    if (typeof Peer !== 'undefined') {
      console.log('✅ PeerJS déjà disponible');
      resolve();
      return;
    }
    
    // CDNs de secours
    const cdnUrls = [
      'https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js',
      'https://cdn.jsdelivr.net/npm/peerjs@1.5.0/dist/peerjs.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.0/peerjs.min.js'
    ];
    
    let attempts = 0;
    
    function tryLoadScript() {
      if (attempts >= cdnUrls.length) {
        console.error('❌ Impossible de charger PeerJS depuis tous les CDNs');
        reject(new Error('PeerJS non disponible'));
        return;
      }
      
      const script = document.createElement('script');
      script.src = cdnUrls[attempts];
      script.async = true;
      
      script.onload = () => {
        console.log(`✅ PeerJS chargé depuis: ${cdnUrls[attempts]}`);
        // Attendre un peu que PeerJS s'initialise
        setTimeout(() => {
          if (typeof Peer !== 'undefined') {
            resolve();
          } else {
            attempts++;
            tryLoadScript();
          }
        }, 500);
      };
      
      script.onerror = () => {
        console.warn(`⚠️ Échec chargement: ${cdnUrls[attempts]}`);
        attempts++;
        tryLoadScript();
      };
      
      document.head.appendChild(script);
    }
    
    tryLoadScript();
  });
}

// Vérification du chargement de PeerJS
window.addEventListener('load', () => {
  console.log('🌐 Tentative de chargement PeerJS...');
  loadPeerJS()
    .then(() => {
      console.log('✅ PeerJS disponible:', Peer.version || 'version inconnue');
      window.peerJSReady = true;
    })
    .catch((error) => {
      console.warn('⚠️ PeerJS non chargé, fonctionnalités P2P désactivées');
      window.peerJSReady = false;
    });
});

console.log('🎯 BILLARD ÉPIQUE - Démarrage !');

// Variables globales simplifiées
const W = 912, H = 532, R = 14, BASE_HOLE = 34;
let HOLE = BASE_HOLE;
const FRICTION = 110, RESTW = 0.88, RESTB = 0.99, STOP = 2.5, MAXPULL = R * 10, AIMX = 4, AIM2 = 0.6, POW = 18;

const C = document.getElementById('game');
const ctx = C.getContext('2d');

const players = [
  {id: 0, name: 'Player 1', color: 'white', assist: true, wins: 0, shots: 0, streak: 0},
  {id: 1, name: 'Player 2', color: 'black', assist: true, wins: 0, shots: 0, streak: 0}
];

let difficulty = 2, balls = [], red = null, turn = 0, dragging = false, dragBall = null, drag = {x: 0, y: 0};
let shot = false, roundOver = false, matchOver = false, hideTurn = false, falls = [];

// Variables IA et P2P
let gameMode = 'local'; // 'local', 'ai', 'host', 'join'
let aiLevel = 1; // 1=Easy, 2=Hard, 3=Insane
let aiThinking = false;

// Variables P2P
let peer = null;
let conn = null;
let myPeerId = null;
let isHost = false;
let myTurn = true;
let lastPingTime = 0;

// SFX système
const sfx = (() => {
  let a = null, last = {w: 0, b: 0, epic: 0};
  const ok = () => a || (a = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null);
  
  function ping(f, d, g, type = 'sine') {
    const A = ok(); if (!A) return;
    const t = A.currentTime, o = A.createOscillator(), g1 = A.createGain();
    o.type = type; o.frequency.setValueAtTime(f, t);
    g1.gain.setValueAtTime(0, t); g1.gain.linearRampToValueAtTime(g, t + .01);
    g1.gain.exponentialRampToValueAtTime(.0001, t + d);
    o.connect(g1).connect(A.destination); o.start(t); o.stop(t + d);
  }
  
  function chord(freqs, d, g) {
    freqs.forEach((f, i) => setTimeout(() => ping(f, d, g), i * 50));
  }
  
  return {
    init() { ok() },
    wall(v) {
      const A = ok(); if (!A || Date.now() - last.w < 30) return; last.w = Date.now();
      ping(280 + Math.min(220, v * 400), .05 + v * .05, Math.min(.2, .05 + v * .12));
    },
    ball(v) {
      const A = ok(); if (!A || Date.now() - last.b < 20) return; last.b = Date.now();
      ping(420 + Math.min(300, v * 550), .05 + v * .05, Math.min(.25, .05 + v * .2));
    },
    fallRed() {
      chord([540, 720, 900, 1080], .3, .25);
    },
    fall() {
      ping(220, .18, .2); ping(160, .22, .16);
    },
    epic() {
      if (Date.now() - last.epic < 1000) return; last.epic = Date.now();
      chord([440, 554, 659, 880], .5, .3);
    },
    victory() {
      setTimeout(() => chord([523, 659, 784, 1047], .8, .4), 0);
      setTimeout(() => chord([659, 784, 988, 1319], .8, .4), 400);
    }
  };
})();

// Utils
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const len = (x, y) => Math.hypot(x, y);
const norm = (x, y) => { const l = len(x, y) || 1; return {x: x / l, y: y / l} };

function makeBall(x, y, c, own) {
  return {id: Math.random(), x, y, vx: 0, vy: 0, r: R, color: c, own, in: true, trail: []}
}

function resetBalls() {
  balls = []; 
  const cx = W / 2, cy = H / 2;
  balls.push(makeBall(cx - 180, cy - 40, 'white', 0), makeBall(cx - 180, cy + 40, 'white', 0));
  balls.push(makeBall(cx + 180, cy - 40, '#111827', 1), makeBall(cx + 180, cy + 40, '#111827', 1));
  const yBottom = H - R, yMid = cy + (yBottom - cy) / 2;
  red = makeBall(cx, yMid, '#e11d48', null);
  balls.push(red);
}

function live(n) { return balls.filter(b => b && b.in && b.own === n).length }
function allStopped() {
  for (const b of balls) {
    if (!b || !b.in) continue;
    if (len(b.vx, b.vy) > STOP) return false
  }
  return true
}

function showCombo(text) {
  const combo = document.createElement('div');
  combo.className = 'combo-text';
  combo.textContent = text;
  C.parentElement.appendChild(combo);
  setTimeout(() => combo.remove(), 2000);
}
function initPeer() {
  console.log('🔗 Initialisation P2P...');
  
  if (typeof Peer === 'undefined') {
    console.error('❌ PeerJS non disponible');
    updateStatus('error', 'PeerJS non chargé');
    return;
  }
  
  try {
    peer = new Peer({
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      }
    });
    
    peer.on('open', (id) => {
      console.log('✅ Peer connecté:', id);
      myPeerId = id;
      document.getElementById('myPeerId').textContent = id;
      updateStatus('connected', 'En attente de connexion...');
      showCombo('🔗 SERVEUR PRÊT!');
    });
    
    peer.on('connection', (connection) => {
      console.log('📥 Connexion reçue');
      conn = connection;
      setupConnection();
      updateStatus('connected', 'Adversaire connecté!');
      showConnectionInfo();
      showCombo('👥 ADVERSAIRE CONNECTÉ!');
    });
    
    peer.on('error', (err) => {
      console.error('❌ Erreur peer:', err);
      updateStatus('error', 'Erreur de connexion');
    });
    
  } catch(e) {
    console.error('❌ Erreur init peer:', e);
    updateStatus('error', 'Impossible de se connecter');
  }
}

function connectToPeer() {
  const friendId = document.getElementById('friendId').value.trim();
  if (!friendId) {
    updateStatus('error', 'Veuillez entrer un ID', true);
    return;
  }
  
  console.log('🔗 Connexion à:', friendId);
  updateStatus('connecting', 'Connexion en cours...', true);
  
  try {
    conn = peer.connect(friendId);
    setupConnection();
  } catch(e) {
    console.error('❌ Erreur connexion:', e);
    updateStatus('error', 'Impossible de se connecter', true);
  }
}

function setupConnection() {
  if (!conn) {
    console.error('❌ Pas de connexion à configurer');
    return;
  }
  
  console.log('🔧 Configuration connexion...');
  
  // Timeout de connexion
  const connectionTimeout = setTimeout(() => {
    if (!conn.open) {
      console.warn('⏰ Timeout connexion P2P');
      updateStatus('error', 'Timeout - Vérifiez l\'ID', gameMode === 'join');
    }
  }, 15000);
  
  conn.on('open', () => {
    clearTimeout(connectionTimeout);
    console.log('✅ Connexion P2P établie!');
    const isJoin = gameMode === 'join';
    updateStatus('connected', 'Connexion établie!', isJoin);
    showConnectionInfo();
    showCombo('🚀 CONNEXION OK!');
    
    // Ping initial
    startPing();
  });
  
  conn.on('data', (data) => {
    console.log('📨 Données reçues:', data?.type || 'unknown');
    handleP2PMessage(data);
  });
  
  conn.on('close', () => {
    clearTimeout(connectionTimeout);
    console.log('❌ Connexion fermée');
    const isJoin = gameMode === 'join';
    updateStatus('error', 'Connexion perdue', isJoin);
    hideConnectionInfo();
    showCombo('⚠️ CONNEXION PERDUE!');
  });
  
  conn.on('error', (err) => {
    clearTimeout(connectionTimeout);
    console.error('❌ Erreur connexion:', err);
    const isJoin = gameMode === 'join';
    updateStatus('error', 'Erreur de connexion', isJoin);
    
    // Suggestions selon l'erreur
    if (err.type === 'peer-unavailable') {
      showCombo('💡 VÉRIFIEZ L\'ID!');
    } else {
      showCombo('💡 RÉESSAYEZ!');
    }
  });
}

function handleP2PMessage(data) {
  console.log('📨 Message reçu:', data.type);
  
  switch(data.type) {
    case 'ping':
      sendP2PMessage({type: 'pong', timestamp: data.timestamp});
      break;
      
    case 'pong':
      const latency = Date.now() - data.timestamp;
      document.getElementById('pingDisplay').textContent = latency;
      document.getElementById('syncDisplay').textContent = latency < 50 ? 'EXCELLENT' : latency < 100 ? 'BON' : 'LAG';
      break;
      
    case 'shot':
      applyRemoteShot(data);
      break;
      
    case 'gameState':
      syncGameState(data);
      break;
      
    case 'turnChange':
      turn = data.turn;
      myTurn = (gameMode === 'host' && turn === 0) || (gameMode === 'join' && turn === 1);
      updTurn();
      break;
      
    case 'playerNames':
      if (gameMode === 'host') {
        players[1].name = data.guestName;
      } else {
        players[0].name = data.hostName;
      }
      updScore();
      break;
  }
}

function sendP2PMessage(data) {
  if (conn && conn.open) {
    try {
      conn.send(data);
    } catch(e) {
      console.error('❌ Erreur envoi:', e);
    }
  }
}

function applyRemoteShot(data) {
  const ball = balls.find(b => b.id === data.ballId);
  if (ball) {
    ball.vx = data.vx;
    ball.vy = data.vy;
    shot = true;
    falls = [];
    players[turn].shots++;
  }
}

function syncGameState(data) {
  balls = data.balls;
  red = balls.find(b => b.color === '#e11d48');
  players[0].wins = data.p1Wins;
  players[1].wins = data.p2Wins;
  updScore();
}

function startPing() {
  setInterval(() => {
    if (conn && conn.open) {
      lastPingTime = Date.now();
      sendP2PMessage({type: 'ping', timestamp: lastPingTime});
    }
  }, 2000);
}

function updateStatus(status, text, isJoin = false) {
  const dotId = isJoin ? 'statusDot2' : 'statusDot';
  const textId = isJoin ? 'statusText2' : 'statusText';
  
  const dot = document.getElementById(dotId);
  const statusEl = document.getElementById(textId);
  
  if (dot && statusEl) {
    dot.className = '';
    statusEl.textContent = text;
    
    switch(status) {
      case 'connecting':
        dot.style.background = '#ff8800';
        dot.style.animation = 'pulse 1s infinite';
        break;
      case 'connected':
        dot.style.background = '#39ff14';
        dot.style.animation = 'none';
        dot.style.boxShadow = '0 0 10px #39ff14';
        break;
      case 'error':
        dot.style.background = '#ff4444';
        dot.style.animation = 'none';
        break;
    }
  }
}

function showConnectionInfo() {
  document.getElementById('connectionInfo').style.display = 'block';
}

function hideConnectionInfo() {
  document.getElementById('connectionInfo').style.display = 'none';
}
function calculateBestShot() {
  const myBalls = balls.filter(b => b && b.in && b.own === 1); // IA joue avec les noires
  if (!myBalls.length) return null;
  
  let bestShot = null;
  let bestScore = -1000;
  
  for (const ball of myBalls) {
    // Essayer différents angles et puissances selon le niveau
    const angleStep = aiLevel === 3 ? 15 : aiLevel === 2 ? 30 : 60;
    const powerStep = aiLevel === 3 ? 0.15 : aiLevel === 2 ? 0.25 : 0.5;
    
    for (let angle = 0; angle < 360; angle += angleStep) {
      for (let power = 0.3; power <= 1; power += powerStep) {
        const shot = {
          ball,
          angle: angle * Math.PI / 180,
          power,
          score: evaluateShot(ball, angle * Math.PI / 180, power)
        };
        
        if (shot.score > bestScore) {
          bestScore = shot.score;
          bestShot = shot;
        }
      }
    }
  }
  
  return bestShot;
}

function evaluateShot(ball, angle, power) {
  let score = 0;
  
  const vx = Math.cos(angle) * power * POW * 100;
  const vy = Math.sin(angle) * power * POW * 100;
  
  // Points pour viser la rouge (priorité absolue)
  const redDist = len(ball.x - red.x, ball.y - red.y);
  const redDirection = norm(red.x - ball.x, red.y - ball.y);
  const shotDirection = norm(vx, vy);
  const redAlignment = redDirection.x * shotDirection.x + redDirection.y * shotDirection.y;
  
  if (redAlignment > 0.6) { // Bon alignement vers la rouge
    score += 200 - redDist * 0.8; // Plus proche = mieux
    
    // BONUS ÉNORME si la rouge va vers le trou
    const holeDirection = norm(W/2 - red.x, H/2 - red.y);
    const redPushAlignment = redDirection.x * holeDirection.x + redDirection.y * holeDirection.y;
    if (redPushAlignment > 0.4) {
      score += 500; // JACKPOT! 🎯
    }
  }
  
  // Points pour viser les boules adverses (stratégie défensive)
  const enemyBalls = balls.filter(b => b && b.in && b.own === 0);
  for (const enemy of enemyBalls) {
    const enemyDist = len(ball.x - enemy.x, ball.y - enemy.y);
    const enemyDirection = norm(enemy.x - ball.x, enemy.y - ball.y);
    const enemyAlignment = enemyDirection.x * shotDirection.x + enemyDirection.y * shotDirection.y;
    
    if (enemyAlignment > 0.6) {
      score += 100 - enemyDist * 0.5;
      
      // Bonus si l'ennemi va vers le trou
      const holeDirection = norm(W/2 - enemy.x, H/2 - enemy.y);
      const enemyPushAlignment = enemyDirection.x * holeDirection.x + enemyDirection.y * holeDirection.y;
      if (enemyPushAlignment > 0.4) {
        score += 200;
      }
    }
  }
  
  // MALUS pour se rapprocher du trou soi-même (éviter le suicide)
  const holeDist = len(ball.x - W/2, ball.y - H/2);
  const holeDirection = norm(W/2 - ball.x, H/2 - ball.y);
  const holeAlignment = holeDirection.x * shotDirection.x + holeDirection.y * shotDirection.y;
  if (holeAlignment > 0.4 && holeDist < 120) {
    score -= 300; // Éviter le suicide!
  }
  
  // Malus pour les tirs trop faibles ou trop forts
  if (power < 0.4) score -= 50;
  if (power > 0.9) score -= 30;
  
  // Randomisation selon le niveau
  if (aiLevel === 1) {
    score += (Math.random() - 0.5) * 300; // Beaucoup de hasard
  } else if (aiLevel === 2) {
    score += (Math.random() - 0.5) * 80;  // Peu de hasard
  }
  // Niveau 3: pas de hasard, calculs parfaits
  
  return score;
}

function executeAIShot() {
  if (!aiThinking || gameMode !== 'ai' || turn !== 1) return;
  
  const shot = calculateBestShot();
  if (!shot) {
    console.log('IA: Aucun tir possible');
    aiThinking = false;
    return;
  }
  
  // Appliquer le tir
  const vx = Math.cos(shot.angle) * shot.power * POW * 100;
  const vy = Math.sin(shot.angle) * shot.power * POW * 100;
  
  shot.ball.vx = vx;
  shot.ball.vy = vy;
  
  // Effets visuels selon la qualité du tir
  if (shot.score > 400) {
    showCombo('IA GENIUS! 🧠');
    sfx.epic();
  } else if (shot.score > 200) {
    showCombo('NICE AI! 👍');
  } else if (shot.score < 0) {
    showCombo('IA PANIC! 😵');
  }
  
  console.log(`IA ${aiLevel === 1 ? 'EASY' : aiLevel === 2 ? 'HARD' : 'INSANE'}: Score=${Math.round(shot.score)}, Power=${shot.power.toFixed(2)}`);
  
  aiThinking = false;
  shot = true;
  falls = [];
  players[1].shots++;
}

// Difficulté
function setDiff(d) {
  difficulty = clamp(d | 0, 1, 3);
  const c1 = document.getElementById('assistP1'), c2 = document.getElementById('assistP2');
  if (difficulty === 3) {
    c1.checked = c2.checked = false;
    c1.disabled = c2.disabled = true;
    players[0].assist = players[1].assist = false;
  } else {
    c1.disabled = c2.disabled = false;
    c1.checked = c2.checked = true;
    players[0].assist = players[1].assist = true;
  }
}

function applyDiff() {
  HOLE = difficulty === 1 ? Math.round(BASE_HOLE * 1.25) :
        difficulty === 3 ? Math.round(BASE_HOLE * 0.75) :
        BASE_HOLE
}

// UI
function updScore() {
  document.getElementById('name1').textContent = players[0].name;
  document.getElementById('name2').textContent = players[1].name;
  document.getElementById('score1').textContent = players[0].wins;
  document.getElementById('score2').textContent = players[1].wins;
}

function updTurn() {
  if (matchOver || !document.getElementById('nextOverlay').classList.contains('hidden') || hideTurn) {
    document.getElementById('turnBanner').style.display = 'none';
    return
  }
  
  const banner = document.getElementById('turnBanner');
  banner.style.display = 'flex';
  
  // Gestion spécifique selon le mode
  if (gameMode === 'ai') {
    if (turn === 0) {
      document.getElementById('turnText').textContent = 'À TOI DE JOUER!';
      
      // Masquer automatiquement après 2 secondes pour ne pas gêner le tactile
      setTimeout(() => {
        if (!shot && !roundOver && !matchOver && turn === 0) {
          banner.style.display = 'none';
        }
      }, 2000);
      
    } else {
      const aiNames = ['IA EASY', 'IA HARD', 'IA INSANE'];
      document.getElementById('turnText').textContent = `${aiNames[aiLevel - 1]} RÉFLÉCHIT...`;
      
      // Délai de réflexion selon le niveau IA
      const thinkTime = aiLevel === 1 ? 800 : aiLevel === 2 ? 2000 : 3500;
      
      if (!aiThinking && !shot && !roundOver) {
        aiThinking = true;
        setTimeout(() => {
          executeAIShot();
        }, thinkTime);
      }
    }
  } else if (gameMode === 'host' || gameMode === 'join') {
    // Mode P2P
    const isMyTurn = (gameMode === 'host' && turn === 0) || (gameMode === 'join' && turn === 1);
    
    if (isMyTurn) {
      document.getElementById('turnText').textContent = 'À TOI DE JOUER!';
      setTimeout(() => {
        if (!shot && !roundOver && !matchOver) {
          banner.style.display = 'none';
        }
      }, 2000);
    } else {
      document.getElementById('turnText').textContent = `${players[turn].name} joue...`;
    }
    
    myTurn = isMyTurn;
  } else {
    // Mode local
    document.getElementById('turnText').textContent = `${players[turn].name} - À TOI DE JOUER!`;
    
    // Masquer automatiquement après 2 secondes en mode local aussi
    setTimeout(() => {
      if (!shot && !roundOver && !matchOver) {
        banner.style.display = 'none';
      }
    }, 2000);
  }
  
  document.getElementById('turnBall').className = 'turn-ball ' + players[turn].color;
}

// Parties & manches
function startMatch() {
  players[0].wins = players[1].wins = 0;
  players[0].shots = players[1].shots = 0;
  players[0].streak = players[1].streak = 0;
  matchOver = false;
  startRound(true);
  updScore();
  
  // En mode host P2P, définir qui commence et synchroniser
  if (gameMode === 'host' && conn && conn.open) {
    turn = Math.random() < 0.5 ? 0 : 1;
    sendP2PMessage({type: 'turnChange', turn});
    sendP2PMessage({
      type: 'gameState',
      balls: balls,
      p1Wins: players[0].wins,
      p2Wins: players[1].wins
    });
  }
}

function startRound(first) {
  roundOver = false; falls = []; applyDiff(); resetBalls();
  if (first) turn = Math.random() < .5 ? 0 : 1;
  shot = dragging = false; dragBall = null; drag = {x: 0, y: 0}; hideTurn = false;
  updTurn();
}

function endRound(winner, why) {
  if (roundOver) return;
  roundOver = true;
  players[winner].wins++;
  players[winner].streak++;
  players[winner ^ 1].streak = 0;
  updScore();
  
  const loser = winner ^ 1;
  let msg = why === 'red-first' ?
    `🔥 ${players[winner].name} DOMINE! (Rouge explosée en premier)` :
    `💀 ${players[loser].name} éliminé! ${players[winner].name} règne!`;
  
  if (players[winner].wins >= 2) {
    matchOver = true;
    document.getElementById('victoryTitle').textContent = '👑 VICTOIRE TOTALE!';
    document.getElementById('victorySubtitle').textContent = `${players[winner].name} écrase la concurrence!`;
    document.getElementById('victoryOverlay').classList.remove('hidden');
    document.getElementById('turnBanner').style.display = 'none';
    sfx.victory();
    showCombo(`CHAMPION: ${players[winner].name}!`);
    return
  }
  
  document.getElementById('roundResult').textContent = msg;
  document.getElementById('nextOverlay').classList.remove('hidden');
  turn = loser;
  updTurn();
}

// Input
function pos(ev) {
  const r = C.getBoundingClientRect();
  const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
  const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
  return {
    x: (clientX - r.left) * (C.width / r.width),
    y: (clientY - r.top) * (C.height / r.height)
  };
}

function pick(p) {
  // En mode IA, on ne peut jouer que si c'est notre tour (joueur 0)
  if (gameMode === 'ai' && turn !== 0) return null;
  
  // En mode P2P, on ne peut jouer que si c'est notre tour
  if ((gameMode === 'host' || gameMode === 'join') && !myTurn) return null;
  
  const id = players[turn].id;
  for (const b of balls) {
    if (!b || !b.in || b.own !== id) continue;
    if (len(p.x - b.x, p.y - b.y) <= b.r) return b
  }
  return null
}

function updatePowerMeter() {
  if (!dragging || !dragBall) return;
  const power = Math.min(1, len(drag.x, drag.y) / MAXPULL);
  document.getElementById('powerFill').style.width = (power * 100) + '%';
}

function handleMove(ev) {
  const p = pos(ev);
  if (!dragging && !shot && !roundOver && !matchOver) {
    C.classList.toggle('grabbable', !!pick(p));
  } else {
    C.classList.remove('grabbable');
  }
  
  if (!dragging || !dragBall) return;
  const v = {x: p.x - dragBall.x, y: p.y - dragBall.y};
  const L = Math.min(MAXPULL, len(v.x, v.y));
  const n = norm(v.x, v.y);
  drag = {x: n.x * L, y: n.y * L};
  updatePowerMeter();
}

function handleStart(ev) {
  ev.preventDefault();
  if (shot || roundOver || matchOver) return;
  
  // En mode IA, on ne peut jouer que si c'est notre tour
  if (gameMode === 'ai' && turn !== 0) return;
  
  // En mode P2P, on ne peut jouer que si c'est notre tour
  if ((gameMode === 'host' || gameMode === 'join') && !myTurn) return;
  
  const b = pick(pos(ev));
  if (!b) return;
  dragging = true; dragBall = b; drag = {x: 0, y: 0};
  C.classList.add('grabbing');
  hideTurn = true; updTurn();
  document.getElementById('powerMeter').classList.add('visible');
}

function handleEnd(ev) {
  ev.preventDefault();
  if (!dragging || !dragBall) return;
  
  dragging = false;
  C.classList.remove('grabbing');
  document.getElementById('powerMeter').classList.remove('visible');
  
  const L = len(drag.x, drag.y);
  if (L < 1) {
    dragBall = null; drag = {x: 0, y: 0};
    hideTurn = false; updTurn();
    return;
  }
  
  const n = norm(drag.x, drag.y), power = POW * (L / MAXPULL);
  const vx = -n.x * power * 100;
  const vy = -n.y * power * 100;
  
  dragBall.vx = vx;
  dragBall.vy = vy;
  
  // Envoyer le tir en P2P
  if ((gameMode === 'host' || gameMode === 'join') && conn && conn.open) {
    sendP2PMessage({
      type: 'shot',
      ballId: dragBall.id,
      vx: vx,
      vy: vy
    });
  }
  
  shot = true; falls = []; dragBall = null; drag = {x: 0, y: 0};
  players[turn].shots++;
  
  if (power > 0.8) {
    showCombo('POWER SHOT!');
    sfx.epic();
  }
}

// Events
C.addEventListener('mousemove', handleMove);
C.addEventListener('mousedown', handleStart);
window.addEventListener('mouseup', handleEnd);
C.addEventListener('touchmove', handleMove, {passive: false});
C.addEventListener('touchstart', handleStart, {passive: false});
C.addEventListener('touchend', handleEnd, {passive: false});

// Physique
function integ(b, dt) {
  if (!b.in) return;
  // Trail effect
  if (len(b.vx, b.vy) > 50) {
    b.trail.push({x: b.x, y: b.y, alpha: 1});
    if (b.trail.length > 8) b.trail.shift();
  }
  b.trail.forEach(t => t.alpha *= 0.9);
  
  b.x += b.vx * dt; b.y += b.vy * dt;
  const v = len(b.vx, b.vy);
  if (v > 0) {
    const nv = Math.max(0, v - FRICTION * dt), f = nv / v;
    b.vx *= f; b.vy *= f;
    if (nv < STOP) { b.vx = b.vy = 0 }
  }
}

function walls(b) {
  if (!b.in) return;
  let hit = false;
  if (b.x - b.r < 0) { b.x = b.r; b.vx = -b.vx * RESTW; hit = true }
  else if (b.x + b.r > W) { b.x = W - b.r; b.vx = -b.vx * RESTW; hit = true }
  if (b.y - b.r < 0) { b.y = b.r; b.vy = -b.vy * RESTW; hit = true }
  else if (b.y + b.r > H) { b.y = H - b.r; b.vy = -b.vy * RESTW; hit = true }
  if (hit) { sfx.wall(Math.min(1, len(b.vx, b.vy) / 300)) }
}

function collide(a, b) {
  if (!a.in || !b.in) return;
  const dx = b.x - a.x, dy = b.y - a.y, d = len(dx, dy), m = a.r + b.r;
  if (d === 0 || d >= m) return;
  const nx = dx / d, ny = dy / d, ov = m - d, p = ov / 2 + .01;
  a.x -= nx * p; a.y -= ny * p; b.x += nx * p; b.y += ny * p;
  const dvx = b.vx - a.vx, dvy = b.vy - a.vy, rel = dvx * nx + dvy * ny;
  if (rel < 0) {
    const imp = -(1 + RESTB) * rel / 2, aix = imp * nx, aiy = imp * ny;
    a.vx -= aix; a.vy -= aiy; b.vx += aix; b.vy += aiy;
  }
  sfx.ball(Math.min(1, len(a.vx - b.vx, a.vy - b.vy) / 350));
}

function hole(b, t) {
  const cx = W / 2, cy = H / 2;
  if (len(b.x - cx, b.y - cy) <= HOLE - 2) {
    b.in = false; b.vx = b.vy = 0;
    if (b === red) {
      sfx.fallRed();
      showCombo('RED BALL!');
    } else {
      sfx.fall();
    }
    falls.push({t, who: b === red ? 'red' : (b.own === 0 ? 'p0' : 'p1')});
  }
}

// Visée
function rayFirst(o, d, maxL) {
  let best = 1 / 0, hit = null, eps = 1e-6, c = [];
  // Murs
  if (Math.abs(d.x) > eps) {
    let tx = ((0 + R) - o.x) / d.x, y = o.y + d.y * tx;
    if (tx > 0 && y >= R && y <= H - R) c.push({t: tx, n: {x: 1, y: 0}});
    tx = ((W - R) - o.x) / d.x; y = o.y + d.y * tx;
    if (tx > 0 && y >= R && y <= H - R) c.push({t: tx, n: {x: -1, y: 0}});
  }
  if (Math.abs(d.y) > eps) {
    let ty = ((0 + R) - o.y) / d.y, x = o.x + d.x * ty;
    if (ty > 0 && x >= R && x <= W - R) c.push({t: ty, n: {x: 0, y: 1}});
    ty = ((H - R) - o.y) / d.y; x = o.x + d.x * ty;
    if (ty > 0 && x >= R && x <= W - R) c.push({t: ty, n: {x: 0, y: -1}});
  }
  
  for (const q of c) {
    if (q.t < best && q.t <= maxL) {
      best = q.t; hit = {type: 'wall', t: q.t, n: q.n}
    }
  }
  
  // Boules
  for (const b of balls) {
    if (!b || !b.in) continue;
    if (dragBall && b.id === dragBall.id) continue;
    const ocx = o.x - b.x, ocy = o.y - b.y, Rc = R + b.r;
    const a = d.x * d.x + d.y * d.y, B = 2 * (d.x * ocx + d.y * ocy), C = ocx * ocx + ocy * ocy - Rc * Rc;
    const disc = B * B - 4 * a * C;
    if (disc < 0) continue;
    const s = Math.sqrt(disc), t1 = (-B - s) / (2 * a), t2 = (-B + s) / (2 * a);
    const t = (t1 > 0 ? t1 : (t2 > 0 ? t2 : 1 / 0));
    if (t > 0 && t < best && t <= maxL) {
      best = t;
      const hx = o.x + d.x * t, hy = o.y + d.y * t, nx = hx - b.x, ny = hy - b.y, l = len(nx, ny) || 1;
      hit = {type: 'ball', t, pt: {x: hx, y: hy}, n: {x: nx / l, y: ny / l}};
    }
  }
  
  if (!hit) return null;
  const pt = hit.pt || {x: o.x + d.x * best, y: o.y + d.y * best};
  return {type: hit.type, pt, normal: hit.n, t: best}
}

function dashed(x1, y1, x2, y2, color = 'rgba(0,255,255,0.8)') {
  ctx.setLineDash([8, 8]);
  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.shadowColor = color;
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.shadowBlur = 0;
}

// Rendu
function render() {
  // Background
  ctx.fillStyle = '#0a2818';
  ctx.fillRect(0, 0, W, H);
  
  // Grille
  ctx.strokeStyle = 'rgba(0,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i < W; i += 50) {
    ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, H); ctx.stroke();
  }
  for (let i = 0; i < H; i += 50) {
    ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(W, i); ctx.stroke();
  }
  
  // Trou central
  const cx = W / 2, cy = H / 2;
  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, HOLE);
  gradient.addColorStop(0, '#000');
  gradient.addColorStop(0.7, '#1a0a0a');
  gradient.addColorStop(1, '#2a1a1a');
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(cx, cy, HOLE, 0, Math.PI * 2);
  ctx.fill();
  
  // Bordure du trou
  ctx.strokeStyle = '#00ffff';
  ctx.lineWidth = 2;
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(cx, cy, HOLE, 0, Math.PI * 2);
  ctx.stroke();
  ctx.shadowBlur = 0;
  
  // Boules
  for (const b of balls) {
    if (!b || !b.in) continue;
    
    // Trail
    if (b.trail) {
      b.trail.forEach((t, i) => {
        if (t.alpha > 0.1) {
          ctx.globalAlpha = t.alpha * 0.6;
          ctx.fillStyle = b.color;
          ctx.beginPath();
          ctx.arc(t.x, t.y, b.r * 0.8, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      ctx.globalAlpha = 1;
    }
    
    // Boule principale
    const grad = ctx.createRadialGradient(b.x - b.r * 0.3, b.y - b.r * 0.3, 1, b.x, b.y, b.r);
    if (b.color === 'white') {
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.7, '#e0e0e0');
      grad.addColorStop(1, '#c0c0c0');
    } else if (b.color === '#111827') {
      grad.addColorStop(0, '#4a4a4a');
      grad.addColorStop(0.7, '#2a2a2a');
      grad.addColorStop(1, '#111827');
    } else {
      grad.addColorStop(0, '#ff6b9d');
      grad.addColorStop(0.7, '#e11d48');
      grad.addColorStop(1, '#be185d');
    }
    
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
    
    // Highlight
    const hgrad = ctx.createRadialGradient(b.x - b.r * 0.4, b.y - b.r * 0.4, 1, b.x, b.y, b.r);
    hgrad.addColorStop(0, 'rgba(255,255,255,0.8)');
    hgrad.addColorStop(0.3, 'rgba(255,255,255,0.3)');
    hgrad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = hgrad;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
    
    // Glow pour la rouge
    if (b === red) {
      ctx.shadowColor = '#ff0080';
      ctx.shadowBlur = 20;
      ctx.strokeStyle = '#ff0080';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r + 2, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
  }
  
  // Visée
  if (dragging && dragBall && players[turn].assist) {
    const bx = dragBall.x, by = dragBall.y;
    const L = len(drag.x, drag.y);
    if (L > 1) {
      const n = norm(drag.x, drag.y), dir = {x: -n.x, y: -n.y}, maxL = L * AIMX;
      
      const h = rayFirst({x: bx, y: by}, dir, maxL);
      if (h) {
        dashed(bx, by, h.pt.x, h.pt.y, 'rgba(0,255,255,0.9)');
        
        // Point d'impact
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(h.pt.x, h.pt.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        let od = null;
        if (h.type === 'wall') {
          const dn = dir.x * h.normal.x + dir.y * h.normal.y;
          od = {x: dir.x - 2 * dn * h.normal.x, y: dir.y - 2 * dn * h.normal.y};
        } else {
          const dn = dir.x * h.normal.x + dir.y * h.normal.y;
          od = {x: dir.x - dn * h.normal.x, y: dir.y - dn * h.normal.y};
          const l = len(od.x, od.y);
          if (l > 1e-6) { od.x /= l; od.y /= l } else od = null;
        }
        
        if (od) {
          dashed(h.pt.x, h.pt.y, h.pt.x + od.x * (maxL * AIM2), h.pt.y + od.y * (maxL * AIM2), 'rgba(255,0,128,0.7)');
        }
      } else {
        dashed(bx, by, bx + dir.x * maxL, by + dir.y * maxL, 'rgba(0,255,255,0.9)');
      }
    }
  }
}

// Boucle principale
let last = 0, tSim = 0;
function loop(ts) {
  const dt = Math.min(.04, (ts - last) / 1000) || 1 / 60;
  last = ts;
  
  // Physique
  for (const b of balls) { if (b && b.in) integ(b, dt) }
  for (const b of balls) { if (b && b.in) walls(b) }
  for (let i = 0; i < balls.length; i++) {
    const a = balls[i]; if (!a || !a.in) continue;
    for (let j = i + 1; j < balls.length; j++) {
      const c = balls[j]; if (!c || !c.in) continue;
      collide(a, c);
    }
  }
  
  // Gestion des chutes
  if (shot) {
    tSim += dt;
    for (const b of balls) { if (b && b.in) hole(b, tSim) }
    
    if (falls.length) {
      const first = falls.reduce((m, e) => e.t < m.t ? e : m, {t: 1 / 0});
      if (first.who === 'red') {
        endRound(turn, 'red-first'); shot = false;
      } else {
        const p0 = live(0), p1 = live(1);
        if (p0 === 0 || p1 === 0) {
          endRound(p0 === 0 ? 1 : 0, 'both'); shot = false;
        }
      }
    }
    
    if (!roundOver && allStopped()) {
      shot = false; tSim = 0; falls = [];
      turn ^= 1;
      
      // Sync changement de tour en P2P
      if (gameMode === 'host' && conn && conn.open) {
        sendP2PMessage({type: 'turnChange', turn});
      }
      
      hideTurn = false; updTurn();
    }
  }
  
  render();
  requestAnimationFrame(loop);
}

// Initialisation événements
function initGame() {
  console.log('🚀 Initialisation du jeu...');
  
  // Gestion des modes de jeu
  document.querySelectorAll('input[name="gameMode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      gameMode = e.target.value;
      const aiSection = document.getElementById('aiSection');
      const p2pSection = document.getElementById('p2pSection');
      const player2Section = document.getElementById('player2Section');
      
      // Reset sections
      aiSection.style.display = 'none';
      p2pSection.style.display = 'none';
      player2Section.style.display = 'block';
      
      if (gameMode === 'ai') {
        aiSection.style.display = 'block';
        player2Section.style.display = 'none';
        
        const aiLevelInput = document.querySelector('input[name="aiLevel"]:checked');
        aiLevel = aiLevelInput ? parseInt(aiLevelInput.value) : 1;
        
        showCombo('🤖 MODE IA ACTIVÉ!');
        
      } else if (gameMode === 'host') {
        p2pSection.style.display = 'block';
        document.getElementById('hostSection').style.display = 'block';
        document.getElementById('joinSection').style.display = 'none';
        player2Section.style.display = 'none';
        
        isHost = true;
        myTurn = true;
        initPeer();
        showCombo('🏠 MODE HÉBERGEMENT!');
        
      } else if (gameMode === 'join') {
        p2pSection.style.display = 'block';
        document.getElementById('hostSection').style.display = 'none';
        document.getElementById('joinSection').style.display = 'block';
        player2Section.style.display = 'none';
        
        isHost = false;
        waitForPeerJS(() => {
          if (!peer) {
            peer = new Peer();
            peer.on('open', () => {
              updateStatus('connected', 'Prêt à se connecter', true);
            });
            peer.on('error', (err) => {
              console.error('❌ Erreur peer join:', err);
              updateStatus('error', 'Erreur P2P', true);
            });
          }
        });
        showCombo('🌐 MODE REJOINDRE!');
        
      } else {
        showCombo('👥 MODE LOCAL!');
      }
    });
  });
  
  // Gestion des niveaux d'IA
  document.querySelectorAll('input[name="aiLevel"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      aiLevel = parseInt(e.target.value);
      const aiNames = ['EASY', 'HARD', 'INSANE'];
      showCombo(`🤖 IA ${aiNames[aiLevel - 1]}!`);
    });
  });
  
  // Bouton de connexion P2P
  const connectBtn = document.getElementById('connectBtn');
  if (connectBtn) {
    connectBtn.addEventListener('click', connectToPeer);
  }
  
  // Bouton START - événement simple et direct
  const startBtn = document.getElementById('startBtn');
  if (startBtn) {
    startBtn.addEventListener('click', () => {
      console.log('🎮 DÉMARRAGE JEU !');
      sfx.init();
      
      // Récupérer les noms selon le mode
      if (gameMode === 'ai') {
        players[0].name = document.getElementById('p1').value.trim() || 'Joueur';
        const aiNames = ['IA EASY', 'IA HARD', 'IA INSANE'];
        players[1].name = aiNames[aiLevel - 1];
        
        // L'IA n'a pas d'assistance de visée
        players[1].assist = false;
        
      } else if (gameMode === 'host') {
        players[0].name = document.getElementById('p1').value.trim() || 'Host';
        players[1].name = 'Guest'; // Sera mis à jour à la connexion
        
        // Envoyer les noms en P2P
        if (conn && conn.open) {
          sendP2PMessage({
            type: 'playerNames',
            hostName: players[0].name
          });
        }
        
      } else if (gameMode === 'join') {
        players[0].name = 'Host'; // Sera mis à jour à la connexion
        players[1].name = document.getElementById('p1').value.trim() || 'Guest';
        
        // Envoyer les noms en P2P
        if (conn && conn.open) {
          sendP2PMessage({
            type: 'playerNames',
            guestName: players[1].name
          });
        }
        
      } else {
        // Mode local
        players[0].name = document.getElementById('p1').value.trim() || 'Joueur 1';
        players[1].name = document.getElementById('p2').value.trim() || 'Joueur 2';
      }
      
      // Difficulté
      const diffInput = document.querySelector('input[name="difficulty"]:checked');
      const diff = diffInput ? parseInt(diffInput.value) : 2;
      setDiff(diff);
      
      // Assistance
      if (difficulty === 3) {
        players[0].assist = players[1].assist = false;
      } else {
        players[0].assist = document.getElementById('assistP1').checked;
        if (gameMode === 'local') {
          players[1].assist = document.getElementById('assistP2').checked;
        } else {
          players[1].assist = false; // IA et P2P pas d'assistance pour P2
        }
      }
      
      // Lancer le jeu
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('gameUI').style.display = 'block';
      startMatch();
      updTurn();
      
      const modeText = gameMode === 'ai' ? `vs ${players[1].name}` : 
                      gameMode === 'host' ? 'HOST P2P' :
                      gameMode === 'join' ? 'JOIN P2P' : 'MODE LOCAL';
      showCombo(`🚀 ${modeText}!`);
    });
  }
  
  // Autres boutons
  document.getElementById('restartBtn').addEventListener('click', goHome);
  document.getElementById('playAgainBtn').addEventListener('click', goHome);
  document.getElementById('nextBtn').addEventListener('click', () => {
    document.getElementById('nextOverlay').classList.add('hidden');
    startRound(false);
  });
  
  // Gestion difficulté
  document.getElementById('diff1').addEventListener('change', () => setDiff(1));
  document.getElementById('diff2').addEventListener('change', () => setDiff(2));
  document.getElementById('diff3').addEventListener('change', () => setDiff(3));
}

function goHome() {
  document.getElementById('victoryOverlay').classList.add('hidden');
  document.getElementById('nextOverlay').classList.add('hidden');
  document.getElementById('gameUI').style.display = 'none';
  document.getElementById('startScreen').style.display = 'block';
  document.getElementById('diff2').checked = true;
  document.getElementById('modeLocal').checked = true;
  
  // Reset P2P
  if (peer) {
    peer.destroy();
    peer = null;
  }
  if (conn) {
    conn.close();
    conn = null;
  }
  
  gameMode = 'local';
  aiThinking = false;
  isHost = false;
  myTurn = true;
  
  // Reset UI
  document.getElementById('aiSection').style.display = 'none';
  document.getElementById('p2pSection').style.display = 'none';
  document.getElementById('player2Section').style.display = 'block';
  hideConnectionInfo();
  
  setDiff(2);
  document.getElementById('assistP1').disabled = document.getElementById('assistP2').disabled = false;
  document.getElementById('assistP1').checked = document.getElementById('assistP2').checked = true;
}

// Démarrage immédiat
console.log('🎯 Chargement terminé !');
document.addEventListener('DOMContentLoaded', initGame);
if (document.readyState !== 'loading') {
  initGame();
}

setDiff(2);
requestAnimationFrame(loop);
</script>
</body>
</html>